import numpy as np
from vehicle import *
"""
This code lets the user define 
 - airfoil (lift curve slope, zero-lift drag coefficient and drag polar)
 - blade (root radius, tip radius, chord, twist and airfoil details)
 - rotor (number of blades, blade details)
    
It includes a solver function that solves blade element momentum theory (implementing Prandtl loss function), accepting the defined rotor, climb velocity (set 0 for hover) and rotational speed.
The function outputs thrust, torque and power generated by the rotor. I will include coefficients too, later.
"""

RHO = 1.225 # Air density 

# Setting up iterative solver parameters
max_iter = 1000                             # Maximum number of iterations
convergence = 1e-5                          # Convergence limit
tol = 0.3                                   # Tolerance factor
n_sections = 200                            # Number of radial section
lambda_v_init = 10                          # Initial guess of inflow ratio


# Solver function
def solver(rotor : Rotor, V, omega):
    lambda_v = 0                            # Initializing inflow ratio

    # Unpacking other parameters (root and tip radius of each blade, and lift curve slope of airfoil)
    R_root = blade.R_root
    R_tip = blade.R_tip
    a = airfoil.a0

    r_sections = np.linspace(R_root, R_tip, n_sections) # Dividing rotor into radial sections
    dr = (R_tip - R_root)/n_sections                    # Change in radius

    T = 0   # Initializing total thrust
    Q = 0   # Initializing total torque

    # Iteratively solving for inflow ratio lambda_v at each radial section
    for r in r_sections:
        r = np.clip(r, R_root + 0.001, R_tip - 0.001)   # Clipping the extreme points more towards the interior to avoid possible convergence
        c = rotor.blade.c(r)                            # Obtaining chord length at r
        theta = rotor.blade.theta(r)                    # Obtaining twist at r
        Or = omega*r                                    # Calculating local tangential velocity
        lambda_c = V/Or                                 # Calculating climb ratio
        lambda_v = lambda_v_init                        # Initializing inflow ratio with initial guess

        # Iterations start here
        for i in range(max_iter):
            f = rotor.prandtl_loss(r, lambda_v)         # Obtaining Prandtl loss at r using initial value of inflow ratio
            sigma = rotor.solidity_local(r)                   # Obtaining local solidity

            # We get a quadratic equation when we combine blade element and momentum theory
            det = ((sigma*a)/(16*f) - lambda_c/2)**2 + (sigma*a*theta*r)/(8*f*R_tip)        # Determinant of said quadratic solution
            lambda_v_new = np.sqrt(det) - ((sigma*a)/(16*f) - lambda_c/2)                   # Calculating new value of inflow ratio due to incorporation of Prandtl loss

            # Checking for convergence
            if np.abs(lambda_v - lambda_v_new) <= convergence:
                lambda_v = lambda_v_new
                break

            # Else adjusting inflow ratio
            else:
                lambda_v = tol*lambda_v + (1-tol)*lambda_v_new
        
        phi = np.arctan(lambda_v)               # Calculating local inflow angle from obtained inflow ratio
        alpha = theta - phi                     # Calculating local effective angle of attack
        CL = airfoil.Cl(alpha)                  # Obtaining local lift coefficient
        CD = airfoil.Cd(alpha)                  # Obtaining local drag coefficient
        Cn = CL*np.cos(phi) - CD*np.sin(phi)    # Calculating local normal force coefficient
        Ct = CL*np.sin(phi) + CD*np.cos(phi)    # Calculating local normal tangential force coefficient
        W = Or*np.sqrt(1 + lambda_v**2)         # Calculating local resultant airspeed

        dT = 0.5 * RHO * W**2 * c * Cn * dr         # Calculating local thrust
        dQ = r * 0.5 * RHO * W**2 * c * Ct * dr     # Calculating local torque

        T += dT         # Summing up local thrust values to get thrust produced by one blade
        Q += dQ         # Summing up local torque values to get torque produced by one blade

    T *= rotor.B        # Total rotor thrust
    Q *= rotor.B        # Total rotor torque
    P = omega*Q         # Rotor power
    return [T, Q, P]    # Returning results as a list





# Test Case
if __name__ == '__main__':
    airfoil = Airfoil(5.75, 0.0113, 1.25)
    blade = Blade(0.125, 0.762, 0.0508,0.0508, np.deg2rad(1), np.deg2rad(1), airfoil)
    rotor = Rotor(2, blade)
    rpm = 960
    omega = (np.pi/30)*rpm
    print(solver(rotor, 0, omega))