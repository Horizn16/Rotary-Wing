import numpy as np

"""
This code lets the user define 
 - airfoil (lift curve slope, zero-lift drag coefficient and drag polar)
 - blade (root radius, tip radius, chord, twist and airfoil details)
 - rotor (number of blades, blade details)
    
It includes a solver function that solves blade element momentum theory (implementing Prandtl loss function), accepting the defined rotor, climb velocity (set 0 for hover) and rotational speed.
The function outputs thrust, torque and power generated by the rotor. I will include coefficients too, later.
"""

RHO = 1.225 # Air density (will import this from an Environment class)

# Airfoil class
class Airfoil:
    def __init__(self, a0, Cd0, e):
        self.a0 = a0                # Lift curve slope
        self.Cd0 = Cd0              # Zero lift drag coefficient
        self.e = e                  # Drag polar
    
    # Lift coefficient calculator
    def Cl(self, alpha):
        return self.a0 * alpha
    
    # Drag coefficient calculator
    def Cd(self, alpha):
        return self.Cd0 + self.e * alpha**2 


# Blade class
class Blade:
    def __init__(self, R_root, R_tip, chord, th, airfoil : Airfoil):
        self.R_root = R_root                                # Root radius
        self.R_tip = R_tip                                  # Tip radius
        self.chord = chord                                  # Chord (set None to allow linear chord)
        self.t = th                                         # Twist angle (set None to allow varying twist)
        self.airfoil = airfoil                              # Airfoil details

    # Chord function (Returns constant if chord is set)
    def c(self, r):
        if self.chord == None:
            return self.R_tip - r
        else:
            return self.chord
    
    # Twist function (returns constant if twist is set)
    def theta(self, r):
        if self.t == None:
            return np.deg2rad(12)*(self.R_tip/r)
        else:
            return self.t


# Rotor class
class Rotor:
    def __init__(self, B, blade : Blade):
        self.B = B                          # Number of blades
        self.blade = blade                  # Blade details

    # Local solidity at a distance r from the center of the rotor
    def solidity(self, r):
        return (self.B*self.blade.c(r)) / (2*np.pi*r)
    
    # Prandtl loss at a distance r from the center
    def prandtl_loss(self, r, lambda_v):
        return (2/np.pi) * np.arccos(np.exp((-self.B/2)*((1 - r/self.blade.R_tip)/lambda_v)))
    

# Setting up iterative solver parameters
max_iter = 1000                             # Maximum number of iterations
convergence = 1e-5                          # Convergence limit
tol = 0.3                                   # Tolerance factor
n_sections = 200                            # Number of radial section
lambda_v_init = 10                          # Initial guess of inflow ratio


# Solver function
def solver(rotor : Rotor, V, omega):
    lambda_v = 0                            # Initializing inflow ratio

    # Unpacking other parameters (root and tip radius of each blade, and lift curve slope of airfoil)
    R_root = blade.R_root
    R_tip = blade.R_tip
    a = airfoil.a0

    r_sections = np.linspace(R_root, R_tip, n_sections) # Dividing rotor into radial sections
    dr = (R_tip - R_root)/n_sections                    # Change in radius

    T = 0   # Initializing total thrust
    Q = 0   # Initializing total torque

    # Iteratively solving for inflow ratio lambda_v at each radial section
    for r in r_sections:
        r = np.clip(r, R_root + 0.001, R_tip - 0.001)   # Clipping the extreme points more towards the interior to avoid possible convergence
        c = rotor.blade.c(r)                            # Obtaining chord length at r
        theta = rotor.blade.theta(r)                    # Obtaining twist at r
        Or = omega*r                                    # Calculating local tangential velocity
        lambda_c = V/Or                                 # Calculating climb ratio
        lambda_v = lambda_v_init                        # Initializing inflow ratio with initial guess

        # Iterations start here
        for i in range(max_iter):
            f = rotor.prandtl_loss(r, lambda_v)         # Obtaining Prandtl loss at r using initial value of inflow ratio
            sigma = rotor.solidity(r)                   # Obtaining local solidity

            # We get a quadratic equation when we combine blade element and momentum theory
            det = ((sigma*a)/(16*f) - lambda_c/2)**2 + (sigma*a*theta*r)/(8*f*R_tip)        # Determinant of said quadratic solution
            lambda_v_new = np.sqrt(det) - ((sigma*a)/(16*f) - lambda_c/2)                   # Calculating new value of inflow ratio due to incorporation of Prandtl loss

            # Checking for convergence
            if np.abs(lambda_v - lambda_v_new) <= convergence:
                lambda_v = lambda_v_new
                break

            # Else adjusting inflow ratio
            else:
                lambda_v = tol*lambda_v + (1-tol)*lambda_v_new
        
        phi = np.arctan(lambda_v)               # Calculating local inflow angle from obtained inflow ratio
        alpha = theta - phi                     # Calculating local effective angle of attack
        CL = airfoil.Cl(alpha)                  # Obtaining local lift coefficient
        CD = airfoil.Cd(alpha)                  # Obtaining local drag coefficient
        Cn = CL*np.cos(phi) - CD*np.sin(phi)    # Calculating local normal force coefficient
        Ct = CL*np.sin(phi) + CD*np.cos(phi)    # Calculating local normal tangential force coefficient
        W = Or*np.sqrt(1 + lambda_v**2)         # Calculating local resultant airspeed

        dT = 0.5 * RHO * W**2 * c * Cn * dr         # Calculating local thrust
        dQ = r * 0.5 * RHO * W**2 * c * Ct * dr     # Calculating local torque

        T += dT         # Summing up local thrust values to get thrust produced by one blade
        Q += dQ         # Summing up local torque values to get torque produced by one blade

    T *= rotor.B        # Total rotor thrust
    Q *= rotor.B        # Total rotor torque
    P = omega*Q         # Rotor power
    return [T, Q, P]    # Returning results as a list





# Test Case
if __name__ == '__main__':
    airfoil = Airfoil(5.75, 0.0113, 1.25)
    blade = Blade(0.125, 0.762, 0.0508, np.deg2rad(1), airfoil)
    rotor = Rotor(2, blade)
    rpm = 960
    omega = (np.pi/30)*rpm
    print(solver(rotor, 0, omega))